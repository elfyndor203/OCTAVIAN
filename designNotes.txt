Dependencies
Error: none
Math: Errors
Messaging: Errors
ECS: Math, Errors, Messaging
Renderer: Math, Errors, Messaging, ECS (minimally)

Header Organization: (below = includes)
Public module header
	module_internal header
		module.c
		module_API.c (for clear separation)

Code Organization:
Public header:
	#include standards

	#include other public headers
Internal header:
	#include public header
	#include standards_internal

	#include other internal headers
module.c:
	#include internal header
	
	#include other internal headers
module_API.c:
	#include public header
	#include internal header
	
Philosophies: 
1. Preallocate as much as possible
2. Don't keep unnecessary CPU-side arrays
3. Keep everything as modular as possible, keep things other than core functions opaque
4. Write everything internally and expose using OCT_ wrappers, again other than core

Scope

1. ECS and Renderer are opaque to each other except for specified getter functions
2. Math types are known to all for ease of use
3. Aside from core (Math, Messaging, Errors), everything is defined using iOCT_ types, and exposed using OCT_ types
4. Information is passed between modules using entityHandles defined in Messaging

Naming

1. API usable: OCT_
2. Internal to one module: iOCT_
3. Internally by other/multiple modules: _OCT_MOD_(MOD)_
4. Scheme: SCOPE_typeName_descriptionText

ECS

1. A scene is simply a collection of entitySets
2. entitySets have globally unique identifiers. 
3. entites and components have set-specific IDs, which are their index in the layer pool.
4. Each entity can have at most one of each component type. To create multiple e.g. hitBox2D, create a child entity and apply that component for memory simplicity.
5. entites are passed between modules using entityHandles, which are also globally unique and correspond to a entitySet/entity pair. 

Renderer

1. Layers work similarly the same way as entitySets, but are distinct.
2. rendererObjects are linked to entities by entityHandle
3. Each time a renderable component is added to ECS componentTypes, the renderer system must handle it explicitly to request vertex data. 

Pipeline

1. Game data e.g. position, hitbox, transform, entity hierarchies are stored in ECS
2. ECS sends messages to Renderer
3. Renderer queries vertex data based on message

Memory

1. As much as possible is preallocated
2. The ONLY things that can be dynamically allocated are new entitySets, which preallocate all the memory for all entities and components unless expanded, and layers in the same way